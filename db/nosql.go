package db

import (
	"context"
	"fmt"
	"os"
	"time"

	"git.platform.manulife.io/oss/url-shortener/model"
	cfenv "github.com/cloudfoundry-community/go-cfenv"
	newrelic "github.com/newrelic/go-agent"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
)

// Database connection pointer
var Database *mongo.Database

var collationFindOptions = options.Find().SetCollation(&options.Collation{Locale: "en", Strength: 2})
var collationFindOneOptions = options.FindOne().SetCollation(&options.Collation{Locale: "en", Strength: 2})
var collationUpdateOptions = options.Update().SetCollation(&options.Collation{Locale: "en", Strength: 2}).SetUpsert(true)
var collationCountOptions = options.Count().SetCollation(&options.Collation{Locale: "en", Strength: 2})

// InitDB initialize the mongo db connection
func InitDB() error {

	var uri, database string

	env := os.Getenv("LOCAL")
	if len(env) > 1 {

		uri = fmt.Sprintf(`mongodb://%s:%s@%s/%s`,
			"username",
			"password",
			"localhost:27017",
			"urlshortener",
		)
		database = "urlshortener"

	} else {

		// extract from VCAP Services
		appEnv, err := cfenv.Current()
		if err != nil {
			fmt.Println(err.Error())
			os.Exit(0)
		}
		if mongoService, err := appEnv.Services.WithLabel("mongodb-odb"); mongoService != nil {
			if err != nil {
				fmt.Println(err.Error())
				os.Exit(0)
			}
			if temp := mongoService[0].Credentials["uri"]; temp != nil {
				uri = temp.(string)
			}
			if temp := mongoService[0].Credentials["database"]; temp != nil {
				database = temp.(string)
			}
		}
	}

	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)

	client, err := mongo.Connect(ctx, options.Client().ApplyURI(uri))
	if err != nil {
		return fmt.Errorf("couldn't connect to mongodb: %v", err)
	}

	fmt.Println("Successfully connected to MongoDB!")

	Database = client.Database(database)
	return nil
}

// Find find by query
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// NOTE: Assumes only Model URL
// TO BE REFACTORED TO HANDLE NEW TYPES IN THE FUTURE
func Find(txn newrelic.Transaction, collectionName string, bsonFilterQuery interface{}) (interface{}, error) {
	defer newrelic.StartSegment(txn, "mongoCollectionFind").End()
	fmt.Printf("Find() Collection %s with query %v\n", collectionName, bsonFilterQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	cursor, err := collection.Find(ctx, bsonFilterQuery, collationFindOptions)
	if err != nil {
		fmt.Printf("Find() Collection %s with query %v. Error: %v\n", collectionName, bsonFilterQuery, err)
		return nil, err
	}
	defer cursor.Close(ctx)

	var returnValue = make([]model.URL, 0)
	for cursor.Next(ctx) {
		var url model.URL
		cursor.Decode(&url)
		if err != nil {
			fmt.Printf("Error decoding %v", err.Error())
		} else {
			returnValue = append(returnValue, url)
		}
	}

	return returnValue, nil
}

// FindOne find one by query
func FindOne(txn newrelic.Transaction, collectionName string, bsonFilterQuery interface{}, dest interface{}) {
	defer newrelic.StartSegment(txn, "mongoCollectionFindOne").End()
	fmt.Printf("FindOne() Collection %s with query %v\n", collectionName, bsonFilterQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	err := collection.FindOne(ctx, bsonFilterQuery, collationFindOneOptions).Decode(dest)
	if err != nil {
		fmt.Printf("FindOne() Collection %s with query %v. Error: %v\n", collectionName, bsonFilterQuery, err)
	}
}

// Upsert upsert by query
func Upsert(txn newrelic.Transaction, collectionName string, bsonFilterQuery interface{}, bsonUpdateQuery interface{}) (interface{}, error) {
	defer newrelic.StartSegment(txn, "mongoCollectionUpsert").End()
	fmt.Printf("Upsert() Collection %s with filter %v with query %v\n", collectionName, bsonFilterQuery, bsonUpdateQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	res, err := collection.UpdateOne(ctx, bsonFilterQuery, bsonUpdateQuery, collationUpdateOptions)
	if err != nil {
		fmt.Printf("Upsert() Collection %s with filter %v with query %v. Error: %v\n", collectionName, bsonFilterQuery, bsonUpdateQuery, err)
	}
	return res, err
}

// InsertOne by query returning nil if error or InsertedID (autogenerated in bsonInsertQuery)
func InsertOne(txn newrelic.Transaction, collectionName string, bsonInsertQuery interface{}) interface{} {
	defer newrelic.StartSegment(txn, "mongoCollectionInsertOne").End()
	fmt.Printf("InsertOne() Collection %s with query %v\n", collectionName, bsonInsertQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	res, err := collection.InsertOne(ctx, bsonInsertQuery)
	if err != nil {
		fmt.Printf("InsertOne() Collection %s with query %v. Error: %v\n", collectionName, bsonInsertQuery, err)
		return nil
	}
	return res.InsertedID
}

// Count count existance by query
func Count(txn newrelic.Transaction, collectionName string, bsonFilterQuery interface{}) (int64, error) {
	defer newrelic.StartSegment(txn, "mongoCollectionCount").End()
	fmt.Printf("Count() Collection %s with query %v\n", collectionName, bsonFilterQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	count, err := collection.CountDocuments(ctx, bsonFilterQuery, collationCountOptions)
	if err != nil {
		fmt.Printf("Count() Collection %s with query %v. Error: %v\n", collectionName, bsonFilterQuery, err)
		return 0, err
	}
	return count, nil
}

// Delete delete by query
func Delete(txn newrelic.Transaction, collectionName string, bsonFilterQuery interface{}) (int64, error) {
	defer newrelic.StartSegment(txn, "mongoCollectionDelete").End()
	fmt.Printf("Delete() Collection %s with query %v\n", collectionName, bsonFilterQuery)

	collection := Database.Collection(collectionName)
	ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)
	count, err := collection.DeleteMany(ctx, bsonFilterQuery)
	if err != nil {
		fmt.Printf("Delete() Collection %s with query %v. Error: %v\n", collectionName, bsonFilterQuery, err)
		return 0, err
	}
	return count.DeletedCount, nil
}
